# 4주차_네트워크 통신하기
#4주차스터디
## 3.4 TCP와 UDP
* 2계층과 3계층은 목적지를 정확히 찾아가기 위한 주소 제공이 목적
* 4계층 동작 프로토콜은 목적지 단말 안에서 동작하는 여러 프로세스중 통신해야 할 목적지 프로세스를 정확히 찾고 패킷 순서가 바뀌지 않도록 조합해 원래 데이터를 만들어내기 위한 목적
### 3.4.1 4계층 프로토콜 (TCP, UDP)과 서비스 포트
* 1.5장에서 배웠던것
	* 인캡슐레이션과 디캡슐레이션 과정에서 각 계층에서 정의하는 헤더가 추가되고 여러 정보가 들어가게 됨
	* 가장 중요한 두 가지 정보
		* 각 계층에서 정의하는 정보
		* 상위 프로토콜 지시자 정보
![](https://user-images.githubusercontent.com/93480617/141238457-6fa755fc-d67b-4ce0-a7db-2de322329678.png)
* 각 계층을 정의하는 정보는 수신 측의 동일 계층에서  사용하기 위한 정보
	* 송신측에서 추가한 2계층 헤더의 MAC 주소 정보는 수신 측의 2계층에서 사용하고 확인
	* 3계층 IP주소 & 4계층 시퀀스 번호, ACK번호도 동일
* 상위 프로토콜 지시자는 디캡슐레이션 과정에서 상위 계층의 프로토콜이나 프로세스를 정확히 찾아가기 위한 목적으로 사용
* 3계층은 프로토콜 번호, 4계층은 포트 번호가 상위 프로토콜 지시자
* TCP/IP스택에서 4계층은 TCP& UDP가 담당
	* 4계층의 목적은 해당 어플리케이션에서 사용하는 프로세스를 정확히 찾고 데이터를 분할한 패킷을 잘 쪼개 보내족 잘 조립하는 것
		* 여기서 패킷을 분할하고 조합하기 위해 TCP 프로토콜에서는 시퀀스 번호와 ACK 번호를 사용
![](252A8784-6FD4-4238-8688-93A5BFD8B17E.png)
* 일반적으로 TCP/IP에서는 클라이언트 - 서버 방식으로 서비스를 제공
	* 클라이언트와 서버용 프로그램을 구분해 개발
* 3계층의 프로토콜 번호, 2계층의 이더 타입과 같은 상위 프로토콜 지시자
	* 출발지와 도착지를 구분해 사용하지 않고 한 개만 사용
* 4계층의 포트 번호(프로토콜 지시자)
	* 출발지와 목적지를 구분해서 처리
* 평소 우리가 표현하는 포트 번호의 기준 : 서버의 포트
	* HTTP TCP 80, HTTPS TCP 443, SMTP TCP 25와 같은 잘 알려진 포트 == Well Known Port
		* 이 포트들은 이미 인터넷 주소 할당기구인 IANA에 등록되고 1023번 이하의 포트 번호를 사용
	* 그 외에 다양한 어플리케이션에 포트번호 할당 == registed port사용
		* 1024~49151번
		* 마찬가지로 등록을 할수 있지만 공식과 비공식번호가 혼재되어있고사설 포트번호로 사용되기도 함
	* 동적, 사설, 임시 포트
		* 49152 ~ 65535
		* IANA에 등록하지 않음
		* 자동할당되거나 사설용도로 할당, 클라이언트의 임시포트번호로 ‘상위 프로토콜 지시자인 포트와 프로토콜 주소 정보 중에서 주요 주소 번호를 운영 체제 내부 파일에서 찾아볼 수 있습니다.’
* ![](IMG_0021.jpeg)
* 서비스 응답과 요청시에 출발ip와 목적지ip는 반대. 

> 주요 포트번호 확인  
> ‘상위 프로토콜 지시자인 포트와 프로토콜 주소 정보 중에서 주요 주소 번호를 운영 체제 내부 파일에서 찾아볼 수 있습니다.’(책참고)  

### 3.4.2 TCP(94)
* TCP프로토콜 
	* 신뢰할수 없는 공용망에서도 정보유실없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 분할된 패킷이 잘 전송되었는지 확인. 
	* 패킷에 번호를 부여하고(sequence number) 잘 전송 되었는지에 대한 응답(Acknowledge number)
	* 한번에 얼마를 보내야 수신자가 데이터를 처리할수있는지 전송크기(Window Size)까지 고려해야됨
		* 이러한 역할들 덕분에 네트워크 상태를 심각하게 고려하지 않아도 안전하게 네트워크를 사용할 수 있음
3.4.2.1 패킷순서, 응답번호
* TCP에서는 분할된 패킷을 잘 분할(시퀀스 번호)하고 수신 측이 잘 조합하도록 순서를 주고 응답 번호를 부여(ACK 번호)
* 두 번호가 상호작용해 순서가 바뀌거나 패킷이 손실되는 것을 파악할 수 있다.
![](3BCA995D-E1D2-46FC-8D0E-50CB8ACA1B83.png)
* 보내는 쪽 : 패킷에 번호를 부여
* 받는 쪽 : 이 번호의 순서가 맞는지 확인
![](3208570B-C6B2-4CEC-AEE8-CD12889F785A.png)
1. 출발지에서 시퀀스 번호를 0으로 보낸다 (SEQ = 0)
2. 수신측에서 0번 패킷을 잘 받았다는 표시로 응답번호(ACK)에 1을 적어 응답, 이때 수신 측에서는 자신이 처음 보내는 패킷이므로 자신의 패킷에 시퀀스 번호 0을 부여
3. 이 패킷을 받은 송신측은 시퀀스 번호를 1로(수신측의 ACK가 1이므로), ACK 번호는 상대방의 0번 시퀀스를 잘 받았다는 의미로 시퀀스 번호를 1로 부여해 다시 전송

3.4.2.2 윈도 사이즈와 슬라이딩 윈도
* TCP는 일방적으로 패킷을 보내는 것이 아니라 상대방이 얼마나 잘 받았는지 확인하기 위해 ACK  번호를 확인하고 다음 패킷을 전송
	* 패킷이 잘 전송되었는지 확인하기 위해 별도 패킷을 받는 것 자체가 통신시간을 늘리지만 송신자와 수신자가 먼 거리에 떨어져 있으면 왕복 지연시간 (Round Trip Time, RTT)가 늘어남
		* 작은 패킷을 보내는데도 응답을 받아야만 하나를 더 보낼 수 있다면 모든 데이터를 전송하는데 긴 시간이 걸림
			* 그래서 데이터를 보낼 때 많은 패킷을 한꺼번에 보내고 응답을 하나만 받음
			* 가능하면 최대한 많은 패킷을 보내는 것이 효율적이지만 네트워크 상태가 좋지 않을 경우 패킷 유실 가능성이 커지므로 적당한 송신량을 결정해야 함
				* 한번에 데이터를 받을 수 있는 데이터 크기를 윈도 사이즈라고 하고 네트워크 상황에 따라 이 윈도 사이즈를 조절하는 것을 슬라이딩 윈도라고 함
![](B4CE2BB0-7B23-48BE-8CA9-2ED3D7B67A4B.png)
				* TCP헤더에서 윈도 사이즈로 표현 가능한 최대 크기는 2^16
				* 실제 64K만큼 윈도 사이즈를 가질 수 있지만 이 사이즈는 회선의 안정성이 높아지고 고속화되는 현대 네트워크에서는 너무 작은 숫자임
					* 점점 고속화, 안정화되는 환경에 적응하기 위해 윈도 사이즈를 대폭 늘려 통신하는데, TCP헤더는 변경 불가이므로 헤더 사이즈를 늘리지 않고 뒤의 숫자를 무시하는 방법으로 윈도 사이즈를 증가시켜 통신
						* 이 방법은 기존의 10배, 100배의 윈도 사이즈 가능
3.4.2.3 3방향 핸드 셰이크
* TCP에서는 유실없는 안전한 통신을 위해 통신 시작 전, 사전 연결작업을 진행
	* 목적지가 데이터를 받을 준비가 안된 상황
		* 데이터를 일방적으로 전송하면 목적지에서는 데이터를 정상처리 불가능 -> 데이터 폐기
		* TCP프로토콜은 이런 상황을 방지하기 위한 방안을 마련
			* 통신 전, 안전하게 데이터를 주고받을수 있는지 확인하는 작업을 거침
			* HOW?
				* 패킷 네트워크에서는 동시에 많은 상대방과 통신
					* 정확한 통신을 위해 통신 전 각 통신에 필요한 리소스를 미리 확보하는 작업이 중요
					* TCP에서는 3번의 패킷을 주고 받으며 통신을 서로 준비하므로 ‘3방향 핸드 셰이크’라고 부름
						* TCP는 이런 3방향 핸드 셰이크의 진행 상황에 따라 상태(State)정보를 부르는 이름이 다름
							* LISTEN : 서버에서 서비스를 제공하기 위해 클라이언트의 접속을 받아들일 수 있는 상태
							* SYN-SENT : 클라이언트에서 통신을 시도할 때 Syn패킷을 보내는데 클라이언트에서는 이 상태를 SYN-SENT라고 부름
								* SYN-RECEIVE : 클라이언트의 Syn을 받는 서버는 RECEIVE상태로 변경되고 Syn, Ack로 응답
							* ESTABLISHED : 이 응답을 받은 클라이언트는 ESTABLISHED상태로 변경하고 그에 대한 응답을 다시 서버로 보냄
								* 서버에서도 클라이언트의 응답을 받고 ESTABLISHED상태로 변경됨
								* 즉, ESTABLISHED상태는 서버와 클라이언트간의 연결이 성공적이라는 의미
![](CA85EA12-E3AE-4C08-8BCB-3A517B7FD4B5.png)
-> 3방향 핸드셰이크 과정이 생기다보니 기존 통신과 새로운 통신을 구분해야 함.
-> 어떤 패킷이 새로운 연결 시도이고 기존 통신에 대한 응답인지 구분을 위해 헤더에 플래그(Flag)라는 값을 넣어 통신
![](48BC7D89-349A-45C5-A93D-755288353E04.png)
-> TCP Flag는 총 6가지가 있고 각각 통신의 성질을 나타냄. 초기 연결, 응답, 정상 종료, 비정상 종료 등의 용도로 사용

### TCP Flag 6가지 용어 정리
> SYN : 연결 시작 용도로 사용. 연결이 시작될 때 SYN 플래그에 1로 표시  
>   
> ACK : ACK번호가 유효할 경우, 1로 표시, 초기 SYN이 아닌 모든 패킷은 기존 메시지에 대한 응답이므로 ACK 플래그가 1로 표기  
>   
> FIN : 연결 종료시 1로 표시. 데이터 전송을 마친 후 정상적으로 양방향 종료시 사용  
>   
> RST : 연결 종료 시 1로 표시. 연결 강제 종료를 위해 연결을 일방적으로 끊을 때 사용  
>   
> URG : 긴급 데이터인 경우, 1로 표시  
>   
> PSH : 서버 측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달할 것을 지시할 때 사용  
>   
![](42BF5385-306B-4538-9832-E13BB4B81A3F.png)


### 3.4.3 UDP(100)
* 4계층의 역할 되돌아보기
	* 신뢰성있는 통신을 위해 미리 연결 확립(3방향 핸드 셰이크)
	* 데이터를 잘 분할하고 조립하기 위해 패킷번호 부여, 수신된 데이터에 대한 응답
	* 데이터를 특정 단위(윈도 사이즈)로 보내고 메모리에 유지하다가 ACK 번호를 받은 후 통신이 잘되면 메모리에서 제거
	* 중간에 유실이 있으면 시퀀스, ACK번호를 비교해가며 이를 파악, 메모리에 유지해 놓은 데이터를 이용해 재전송
-> TCP만 해당, UDP에는 이런 기능이 전혀 없음

* 데이터 통신의 핵심 : 데이터 전송의 신뢰성
	* 신뢰성 = 어플리케이션에서 걱정하지 않고 데이터를 만들고 사용하게 하는 것
	* UDP는 데이터 전송을 보장하지 않는 프로토콜이므로 제한된 용도로만 사용

* UDP 사용 예시
	* 응성 데이터, 실시간 스트리밍과 같이 시간에 민감한 프로토콜
	* 사내방송, 증권 시세 데이터 전송에 사용되는 멀티캐스트처럼 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경에서 주로 사용
	* 즉, 대부분 음성이나 동영상과 같이 사람이 청각, 시각적으로 응답시간에 민감한 경우에 사용
		* 이런 데이터들은 다른 일반 데이터처럼 취급시 시간 지연이 발생
		* 중간에 데이터 몇 개 유실되는 것보다 재 전송하기 위해 잠시 동영상이나 음성이 멈추는 것이 더 이상하기 때문
			* UDP는 중간에 일부 데이터가 유실되더라도 유실된 상태로 데이터를 처리해버림

* UDP는 TCP와 달리 통신 전 3방향 핸드 셰이크와 같은 절차가 없고 대신 UDP에서 첫 데이터는 리소스 확보를 위해 인터럽트를 거는 용도로 사용되고 유실됨
	* 그래서 UDP프로토콜을 사용하는 어플리케이션이 대부분 이런 상황을 인지하고 동작하거나 연결 확립은 TCP 프로토콜을 사용하고 어믈리케이션끼리 모든 준비를 마치고 실제 데이터만 UDP를 사용하는 경우가 대부분
> **참고**  
> 같은 동영상 스트리밍도 넷플릭스, 유튜브와 같은 시간에 민감하지 않은 단일 시청자를 위한 연결은 TCP를 사용. 이 경우 수초 ~수분의 동영상 데이터를 미리 받아놓고 잠시 문제가 발생하더라도 끊기지 않도록 캐시에 저장  
> 하디만 실시간 회의의 경우 양방향 전송으로 매우 민감하기때문에 TCP를 사용하여 데이터 유실 발생시 네트워크 품질이 나쁘다고 판단할 수 있어 UDP를 사용  
>   
![](4DBC8462-1DF0-4F86-BEA7-DB33F579E45A.png)

## 3.5 ARP(103)
* OSI 2,3계층에서 물리적, 논리적 주소를 사용하여 데이터가 목적지를 찾아가지만 MAC주소와 IP주소 사이에는 아무런 연관이 없음
	* 실제로 통신은 IP 주소 기반으로 일어나고 MAC 주소는 상대방의 주소를 자동으로 알아내 통신하게 되는데 이때 IP주소를 이용해 상대방의 MAC주소를 알아내기 위한 프로토콜이 ARP(Address Resolution Protocol)이다.
### 3.5.1 ARP란?(103)
* IP 주소 체계는 물리적인 MAC주소와 전혀 연관성이 없기 때문에 이 둘을 연계시켜주기 위한 메커니즘이 필요. -> 이때 사용되는 프로토콜이 ARP
![](D0F8AE13-54C5-497B-8EC8-158FBD1AFD1B.png)
* ARP프로토콜은 TCP/IP 프로토콜 스택을 위해서만 동작하지 않는다.
	* TCP—이더넷 프로토콜과 같은 IP와 MAC주소사이에 관계가 없는 대부분의 프로토콜에서 ARP프로토콜과 같은 메커니즘을 사용해 물리적주소와 논리적주소를 연결

* 호스트에서 아무 통신이 없다가 처음 통신을 시도하면 패킷을 바로 캡슐화할 수 없다.
	* 이유 : 통신을 시도할 때 출발, 목적지 IP주소는 알고있지만 상대방의 MAC주소를 모르면 2계층에서의 캡슐화가 불가능하기 때문
		* 상대방의 MAC주소를 알아내려면 ARP 브로드캐스트를 이용해 네트워크 전체에 상대방의 MAC주소의 행방을 물어봐야 함

* ARP 브로드캐스트를 받은 목적지는 ARP 프로토콜을 이용해 자신의 MAC 주소를 응답
	* 이 작업이 완료되면 패킷의 인캡슐레이션이 진행될 수 있음
> 터미널 or CMD에 arp를 쳐보자  
```
arp -a
```
![](B60D9568-02C8-493B-89A2-CC3212FF8F36.png)
> PC의 ARP 테이블정보를 확인할 수 있다. ARP 프로토콜을 이용해 IP 주소와 맥 주소를 매핑하면 “유형” 필드에 “동적”으로 표기된다  

* 패킷 네트워크에서는 큰데이터를 잘라 여러 개의 패킷을 전송
	* 때문에 패킷을 보낼 때마다 ARP 브로드캐스트를 수행하면 네트워크 통신의 효율성이 크게 저하 -> 메모리에 이 정보를 저장해두고 재사용
	* 성능 유지를 위해서는 ARP 테이블을 오래 유지하는 것이 좋지만 IP주소는 언제든지 바뀔 수 있으므로 일정 시간동안 통신이 없을 경우 테이블은 삭제 됨

* 네트워크 장비에서 ARP 작업은 하드웨어 가속으로 처리되지 않고 CPU에서 직접 수행하므로 짧은 시간에 많은 ARP 요청이 들어오면 큰 부하로 작용
	* 주로 해커들이 이를 이용하여 다량 ARP를 이용한 공격들을 수행
	* 대응 방법
		* 네트워크 장비는 ARP 테이블 저장 기간을 일반 PC보다 길게 설정하고 많은 ARP요청이 들어오면 이를 필터링하거나 천천히 처리하는 방식으로 네트워크 장비를 보호
		* 이 외에도 일부 장비는 ARP테이블을 수동으로만 갱신하도록 설정하여 운영
			* 특히, 회선 사업자가 임대하는 네트워크 장비는 MAC 테이블이나 ARP테이블을 정적으로 유지해야 하기 때문에 외부 회선에 연결된 네트워크 장비가 변경된 경우, 반드시 이 정보를 회선 사업자에게 알려줘야함
> 패킷으로 데이터를 전송하는 네트워크에서는 데이터를 보내기 위해 여러 개의 패킷을 사용해야 하므로 반복작업을 줄이기 위해 참조할 수 있는 여러가지 테이블을 사용.  
> ARP 테이블 외에도 DNS 캐시나 라우팅 캐시와 같이 다양한 계층에서 네트워크의 성능을 높이기 위한 캐시 테이블을 가지고 있다.  
### 3.5.2 ARP 동작(105)
* ARP 패킷은 여러가지 필드 중 
	* ARP 데이터에 사용되는 송신자 하드웨어 MAC주소
	* 송신자 IP프로토콜 주소
	* 대상자 MAC주소
	* 대상자 IP주소 4개의 필드가 중요하게 사용됨
![](F884C6E2-C22E-497A-9EE9-1EC4C6045AE7.png)
-> ARP가 이 4개의 필드를 이용해 어떻게 동작하는지 예제를 통해 알아보자.

1. 서버A에서 B로 ping을 보낼려 할 때, A에서는 3계층의 IP까지는 캡슐화 할 수 있지만 	B의 MAC주소는 모르기 때문에 정상적인 패킷을 만들 수 없음
2. B의 MAC주소를 알아내기 위해 ARP요청을 네트워크에 브로드캐스트한다.
3. ARP 패킷을 네트워크에 브로드캐스트 할 때 2계층 MAC주소는 출발지를 자신의	MAC으로, 도착지는 브로드캐스트 (FF-FF-FF-FF-FF-FF)로 채우고 ARP프로토콜 	필드의 전송자 MAC과 IP주소에는 자신의 주소로, 대상자 IP주소는 0.1.1.2를, 대상자 MAC주소는 00-00-00-00-00으로 채워 네트워에 뿌림
4. 2계층 목적지 주소가 브로드캐스트이므로, 이 ARP 패킷은 같은 네트워크 안에 있는 모든 단말에 보내지고 모든 단말은 ARP 프로토콜 내용을 확인하는데 ARP 프로토콜 필드의 대상자 IP 주소가 자신이 맞는지 확인해 자신이 아니면 ARP 패킷을 버림
5. 서버 B가 ARP요청을 받게되면 대상자 IP주소가 일치하므로 응답을 보냄
6. 다시 응답을 하므로 송신자와 대상자의 위치가 바뀜
7. 응답을 할때는 B는 A의 IP, MAC주소를 모두 알고 있기에 ARP테이블을 채워서 응답
8. A는 B의 MAC주소를 알 수 있게 되었다.

* ARP 요청을 처음 보낼 때는 브로드캐스트 (2계층 목적지 MAC주소가 브로드캐스트이므로)
* ARP 응답을 보낼 때는 출발지와 도작지 MAC주소가 명시되있으므로 유니캐스트

* 서버 A는 B로부터 ARP응답을 받아 자신의 ARP 캐시 테이블을 갱신하며 이 캐시 테이블은 정해진 시간동안 통신이 없을때까지 유지되고 초기화

### 3.5.3 GARP(107)
* 일반적인 ARP외에도 ARP프로토콜 필드를 사용하지만 내용을 변경해 다른용도로 사용하는 프로토콜이 존재함
	* GARP (Gratuitous ARP)
		* 대상자 IP 필드에 자신의 IP주소를 채워 ARP 요청을 보냄
		* 자신의 IP주소와 MAC주소를 알려주는 목적으로 사용
		* GARP는 로컬 네트워크에 자신의 IP와 MAC주소를 알리는 목적이므로 GARP의 목적지 MAC주소는 브로드캐스트 MAC주소를 사용
			* ARP요청과 공통점 : 대상자 MAC 주소를 00:00:00:00:00:00인것
			* ARP요청과 차이점 : 송신자와 대상자 IP주소가 자신으로 동일한것
		* 사용 목적
			1. IP 주소 충돌 감지
				1. IP주소는 고유해야 하지만 여러 가지 이유로 겹칠 수 있기때문에 통신 충돌 예방차원에서 미리 GARP를 통해 확인
				2. 당연히 응답이 오면 안된다.
			2. 상대방(동일 서브넷 상의 다른)의 ARP테이블 갱신
				1. ARP과정에서 응답의 경우와 비슷
				2. 가상 MAC주소를 사용하지 않는 데이터베이스 HA(High Availability : 고가용성) 송류션에서 주로 사용
				3. 데이터베이트 HA는 주로 두 데이터베이스 서버가 하나의 가상 IP주소로 서비스 - 액티브 / 스탠바이 이중화
				4. 
			3. HA(고가용성)용도의 클러스터링, VRRP, HSRP

### 3.5.4 RARP
* RARP는  Reverse ARP즉, 반대로 동작하는 ARP
* GARP와 마찬가지로 ARP 프로토콜 구조는 같지만 필드에 들어가는 내용이 다르고 원래의 목적과 반대로 사용
![](33C174D2-E7D2-4C23-8BA4-7D04ECADB4BF.png)
	* IP주소가 정해져 있지 않은 단말이 IP할당을 요청할 때 사용
		* ARP = 통신해야 할 상대방의 MAC주소를 모를때 IP로 MAC을 알아내기 위해
		* RARP = 나의 MAC주소는 알지만 IP가 아직 할당되지 않아 IP를 할당해주는 서버에 어떤 IP주소를 써야 하는지 물어볼 때 사용
			* 과거에 네트워크 호스트의 주소 할당에 사용되었지만 현재는 BOOTP, DHCP로 대체되어 사용되지 않음

## 3.6 서브넷과 게이트웨이(113)
key point == 동일네트워크와 원격지 네트워크 간 통신 동작 방법과 그 차이

### 3.6.1 서브넷과 게이트웨이의 용도(113)
* 로컬에서는 ARP를 이용해 MAC주소를 학습하고 통신할 수 있지만 원격 네트워크 통신은 네트워크를 넘어 전달되지 못하는 브로드 캐스트의 성질 때문에 네트워크 장비의 도움이 필요
	* 이 장비를 ‘게이트웨이(Gateway)’라고 하고 게이트웨이에 대한 정보를 PC나 네트워크 장비에 설정하는 항목이 ‘기본 게이트웨이(Default Gateway)’이다.
![](371826E2-0D43-4C7B-BA52-FE33CBA57443.png)
* 기본 게이트웨이는 3계층 장비가 수행, 여러 네트워크가 연결되면 적절한 경로를 지정해주는 역할
* 5장 라우터/L3 스위치 : 3계층 장비에서 더 자세히 배웁니다.

### 3.6.2 2계층 통신 vs 3계층 통신(116)

