# TCP & UDP

: TCP/IP 프로토콜 스택의 4계층에서 동작하는 TCP와 UDP 프로토콜

→ 2계층과 3계층은 목적지를 정확히 찾아가기 위한 주소 제공이 목적이었다.

→ 4계층에서 동작하는 프로토콜은 목적지 단말 안에서 동작하는 여러 애플리케이션 프로세스 중 통신해야 할 목적지 프로세스를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해 원래 데이터를 잘 만들어내기 위한 역할을 한다.

## 4계층 프로토콜(TCP, UDP)과 서비스 포트

인캡슐레이션, 디캡슐레이션 과정에 각 계층에서 정의하는 헤더가 추가되고 여러 가지 정보가 들어가는데, 그 정보 들 중 가장 중요한 두 가지 정보는
- 각 계층에서 정의하는 정보
- 상위 프로토콜 지시자 정보

송신 측에서 추가한 4계층의 정보(시퀀스 번호, ACK 번호 등)는 수신 측 4계층에서 확인하고 사용한다.

상위 프로토콜 지시자는 디캡슐레이션 과정에서 상위 계층의 프로토콜이나 프로세스를 정확히 찾아가기 위한 목적으로 사용되는데, 2계층은 이더 타입, 3계층은 프로토콜 번호, 4계층은 포트 번호가 상위 프로토콜 지시자이다.

TCP/IP 프로토콜 스택에서 4계층은 TCP와 UDP가 담당한다. 4계층의 목적은 목적지를 찾아가는 주소가 아니라 애플리케이션에서 사용하는 프로세스를 정확히 찾아가고 데이터를 분할한 패킷을 잘 쪼개 보내고 잘 조립하는 것인데,  패킷을 분할하고 조합하기 위해 TCP 프로토콜에서는 시퀀스 번호와 ACK 번호를 사용한다.

- TCP/IP 프로토콜 스택에서 4계층의 상위 프로토콜 지시자는 포트 번호
- 4계층 프로토콜 지시자인 포트 번호는 출발지와 목적지를 구분해 처리
- 서비스 요청 시와 응답 시에는 출발지 IP와 목적지 IP가 반대가 되듯이 출발지와 도착지 포트 번호도 요청 패킷과 응답 패킷이 반대
    

## TCP

: TCP는 4계층의 특징을 대부분 포함하는데,

TCP 프로토콜은 신뢰할 수 없는 공용망에서도 정보유실 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 분할된 패킷이 잘 전송되었는지 확인하는 기능이 있다. → **신뢰할 수 있음**

- 패킷에 번호(Sequence Number)를 부여하고 잘 전송되었는지에 대해 응답(Acknowledge Number)한다.
- 수신자가 잘 받아 처리할 수 있는 전송 크기(Window Size)를 고려해 통신한다.
### **패킷 순서, 응답 번호**

⇒ TCP에서는 패킷을 잘 분할하고 수신 측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여한다

- 패킷에 순서를 부여 : **시퀀스 번호**
- 응답 번호를 부여: **ACK 번호**

⇒ 이 두 번호를 이용해 패킷의 순서가 바뀌거나 중간에 손실된 패킷을 파악할 수 있다.

⇒ 보내는 쪽에서 패킷에 번호를 부여하고 받는 쪽은 이 번호의 순서가 맞는지 확인합니다. 받은 패킷 번호가 맞으면 응답을 주는데 이때 다음 번호의 패킷을 요청한다. ( 이 숫자를 **ACK 번호**라고 함)

### **윈도 사이즈와 슬라이딩 윈도**

- 윈도 사이즈: 한 번에 데이터를 받을 수 있는 데이터 크기(적절한 송신량을 결정)
- 슬라이딩 윈도: 네트워크 상황에 따라 이 윈도 사이즈를 조절하는 것

 

⇒ TCP 통신은 신뢰할 수 있다는 장점이 있지만 매번 패킷의 전송 상태를 확인하려는 과정에서 비용소비가 큰 편이다. 그래서 데이터를 보낼 때 패킷을 하나만 보내는게 아니라 많은 패킷을 한 번에 보낸 뒤 응답을 하나만 받는다.  최대한 한번에 많은 패킷을 보내는게 효율적이지만, 많은 양을 한번에 보낸다면 네트워크 환경에 따라 패킷이 유실될 때 피해가 크기에 적절한 송신양을 결정해야 한다.

TCP 헤더에서 윈도사이즈로 표현할 수 있는 최대 크기는 2^16 = 216이다.  이는 64k만큼 윈도사이즈를 가질 수 있다는 의미지만 현대에와서 이 사이즈는 너무 부족하다. 이를 해결하기 위해 **TCP 헤더 사이즈를 늘리지 않고 뒤의 숫자를 무시하는 방법으로 윈도 사이즈를 증가시켜 통신**하는데, 이런 방식을 사용하면 기존 숫자의 10배, 100배로 윈도 사이즈가 커진다.

⇒ TCP에서 데이터 유실이 발생하는 경우: 윈도 사이즈를 절반으로 줄이고 정상적인 통신이 되는 경우 서서히 원래 사이즈로 늘린다. 네트워크 경합이 발생해서 패킷 유실이 생기면 작아진 윈도 사이즈로 인해 데이터 통신 속도가 느려져 회선을 제대로 사용하지 못하는 경우가 생길 수 있는데, 이를 해결하기 위해 회선 속도 증가, 버퍼가 큰 네트워크 장비 사용 아니면 TCP 최적화 솔루션을 통해 문제를 해결할 수 있다.

### **3방향 핸드셰이크**


TCP에서는 유실없는 안전한 통신을 위해 통신 시작 전에 사전 연결 작업을 함. (데이터를 받을 준비가 안 된 상황에서 데이터를 일방적으로 전송하면 목적지에서는 데이터를 정상적으로 처리할 수 없어 데이터가 버려짐)

패킷 네트워크에서는 동시에 많은 상대방과 통신하므로 정확한 통신을 위해서는 통신 전, 각 통신에 필요한 리소스를 미리 확보하는 작업이 중요하다.

⇒ TCP에서는 3번의 패킷을 주고받으면서 통신을 서로 준비한다. 이를 ‘**3방향 핸드셰이크**’라고 부른다.

TCP에서는 이런 3방향 핸드셰이크를 진행 상황에 따라 상태 정보를 부르는 이름이 다르다.

- **LISTEN**: 서버에서 서비스를 제공하기 위해 클라이언트 접속을 받아들일 수 있는 상태
- **SYN-SENT**: 클라이언트에서 SYN 패킷을 보내는 상태
- **SYN-RECEIVE**: 클라이언트의 SYN 패킷을 받은 서버의 상태
- **ESTABLISHED:**
    - 클라이언트일 경우 :  서버로부터 SYN, ACK 응답받은 상태
    - 서버일 경우:  클라이언트로부터 ACK 응답받은 상태

### 3방향 핸드셰이크 실행 순서

1. 서버는 서비스를 제공하기 위해 클라이언트의 접속을 받아들일 수 있는 **LISTEN** 상태로 대기한다.  
2. 클라이언트에서는 통신을 시도할 때 SYN 패킷을 보내며 이 상태를 **SYN-SENT**라 하는데 서버에서는 클라이언트의 SYN 패킷을 받으면 SYN-RECEIVE 상태로 변경되고 클라이언트로 SYN, ACK을 응답한다. 
3. 클라이언트는 이 응답(SYN, ACK)을 받으면 **ESTABLISHED** 상태로 변경되고 이에 대한 응답(ACK)을 다시 서버로 보낸다.  
4. 서버에서도 이 응답을 받고 **ESTABLISHED**상태로 변경되며 클라이언트와 서버 양 측이 모두 **ESTABLISHED** 상태가 되었다는 것은 연결이 성공적으로 완료되었음을 나타낸다.

⇒ 3방향 핸드셰이크 과정이 생김으로 인해 기존 통신과 새로운 통신을 구분해야 하는데, 이를 구분하기 위해 헤더에 플래그(flag)라는 것을 넣어 통신한다. TCP 플래그는 총 6가지로 통신의 성질을 나타낸다.

모든 플래그는 1비트로 정의되고 아래의 순서대로 배열된다.

- **SYN(연결 시작)**: 연결 시작 용도로 사용한다. 연결이 시작될 때 SYN 플래그에 1로 표시해 보낸다.
- **ACK(확인 응답):** ACK 번호가 유효할 경우 1로 표시해 보낸다. 
초기 SYN이 아닌 모든 패킷은 기존 메세지에 대한 응답이기에 ACK 플래그가 1로 표기된다.
- **RST(강제 연결 종료)**: 연결 종료 시 1로 표시된다. 연결 강제 종료를 위해 연결을 일방적으로 끊을 때 사용된다.
- **PSH(삽입)**: 서버측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달 할 것을 지시할 때 사용된다.
- **URG(긴급)**: 긴급 데이터인 경우, 1로 표시해 보낸다.
- **FIN(종료)**: 연결 종료 시 1로  표시된다. 데이터 전송을 마친 후 정상적으로 양방향 종료 시 사용된다
## UDP

: TCP와 달리 UDP는 4계층 프로토콜이 가져야 할 특징이 거의 없다. TCP에서 소개한 4계층의 여러 안전 장치 기능들이 UDP에는 없고, UDP 헤더도 TCP 헤더와 비교하면 내용이 거의 없다.
⇒ UDP는 데이터 전송을 보장하지 않는 프로토콜이므로 제한된 용도로만 사용함

### UDP의 용도

- 음성 데이터나 실시간 스트리밍과 같이 시간에 민감한 프로토콜이나 애플리케이션을 사용
- 사내 방송이나 증권 시세 데이터 전송에 사용되는 멀티캐스트처럼 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경에서 주로 사용

⇒ 신뢰성보다는 일부 데이터가 유실되더라도 시간에 맞춰서 계속 전송하는것이 중요한 시스템에서 UDP를 사용하게 된다. **UDP에서는 일부 데이터가 유실되더라도 그대로 데이터를 처리한다.**

### UDP의 특징

- UDP는 TCP와 다르게 3방향 핸드셰이크처럼 사전에 연결을 확립하는 과정이 없다. 대신 UDP의 첫 데이터는 리소스 확보를 위해 인터럽트(Interrupt)를 거는 용도로 사용되고 유실된다 (UDP 프로토콜을 사용하는 앱 대부분은 이런 상황을 인지하고 동작함)
- 연결 확립은 TCP 프로토콜을 이용하고 앱끼리 모든 준비를 마친 후 실제 데이터만 UDP를 이용하는 경우가 대부분이다.

---

# ARP

## ARP 동작

## GARP

## RARP

---

# 서브넷과 게이트웨이

## 서브넷과 게이트웨이의 용도

## 2계층 통신 vs 3계층 통신