# TCP & UDP

: TCP/IP 프로토콜 스택의 4계층에서 동작하는 TCP와 UDP 프로토콜

→ 2계층과 3계층은 목적지를 정확히 찾아가기 위한 주소 제공이 목적이었다.

→ 4계층에서 동작하는 프로토콜은 목적지 단말 안에서 동작하는 여러 애플리케이션 프로세스 중 통신해야 할 목적지 프로세스를 정확히 찾아가고 패킷 순서가 바뀌지 않도록 잘 조합해 원래 데이터를 잘 만들어내기 위한 역할을 한다.

## 4계층 프로토콜(TCP, UDP)과 서비스 포트

인캡슐레이션, 디캡슐레이션 과정에 각 계층에서 정의하는 헤더가 추가되고 여러 가지 정보가 들어가는데, 그 정보 들 중 가장 중요한 두 가지 정보는

- 각 계층에서 정의하는 정보
- 상위 프로토콜 지시자 정보

송신 측에서 추가한 4계층의 정보(시퀀스 번호, ACK 번호 등)는 수신 측 4계층에서 확인하고 사용한다.

상위 프로토콜 지시자는 디캡슐레이션 과정에서 상위 계층의 프로토콜이나 프로세스를 정확히 찾아가기 위한 목적으로 사용되는데, 2계층은 이더 타입, 3계층은 프로토콜 번호, 4계층은 포트 번호가 상위 프로토콜 지시자이다.

TCP/IP 프로토콜 스택에서 4계층은 TCP와 UDP가 담당한다. 4계층의 목적은 목적지를 찾아가는 주소가 아니라 애플리케이션에서 사용하는 프로세스를 정확히 찾아가고 데이터를 분할한 패킷을 잘 쪼개 보내고 잘 조립하는 것인데,  패킷을 분할하고 조합하기 위해 TCP 프로토콜에서는 시퀀스 번호와 ACK 번호를 사용한다.

- TCP/IP 프로토콜 스택에서 4계층의 상위 프로토콜 지시자는 포트 번호
- 4계층 프로토콜 지시자인 포트 번호는 출발지와 목적지를 구분해 처리
- 서비스 요청 시와 응답 시에는 출발지 IP와 목적지 IP가 반대가 되듯이 출발지와 도착지 포트 번호도 요청 패킷과 응답 패킷이 반대

## TCP(Transmission Control Protocol)

: TCP는 4계층의 특징을 대부분 포함하는데,

TCP 프로토콜은 신뢰할 수 없는 공용망에서도 정보유실 없는 통신을 보장하기 위해 세션을 안전하게 연결하고 데이터를 분할하고 분할된 패킷이 잘 전송되었는지 확인하는 기능이 있다. → **신뢰할 수 있음**

- 패킷에 번호(Sequence Number)를 부여하고 잘 전송되었는지에 대해 응답(Acknowledge Number)한다.
- 수신자가 잘 받아 처리할 수 있는 전송 크기(Window Size)를 고려해 통신한다.
- 네트워크 상태를 고려하지 않고 쉽고 안전하게 네트워크 사용이 가능하다

### **패킷 순서, 응답 번호**

⇒ TCP에서는 패킷을 잘 분할하고 수신 측이 잘 조합하도록 패킷에 순서를 주고 응답 번호를 부여한다

- 패킷에 순서를 부여 : **시퀀스 번호**
- 응답 번호를 부여: **ACK 번호**

⇒ 이 두 번호를 이용해 패킷의 순서가 바뀌거나 중간에 손실된 패킷을 파악할 수 있다.

⇒ 보내는 쪽에서 패킷에 번호를 부여하고 받는 쪽은 이 번호의 순서가 맞는지 확인합니다. 받은 패킷 번호가 맞으면 응답을 주는데 이때 다음 번호의 패킷을 요청한다. ( 이 숫자를 **ACK 번호**라고 함)

### **윈도 사이즈와 슬라이딩 윈도**

- 윈도 사이즈: 한 번에 데이터를 받을 수 있는 데이터 크기(적절한 송신량을 결정)
- 슬라이딩 윈도: 네트워크 상황에 따라 이 윈도 사이즈를 조절하는 것

 

⇒ TCP 통신은 신뢰할 수 있다는 장점이 있지만 매번 패킷의 전송 상태를 확인하려는 과정에서 비용소비가 큰 편이다. 그래서 데이터를 보낼 때 패킷을 하나만 보내는게 아니라 많은 패킷을 한 번에 보낸 뒤 응답을 하나만 받는다.  최대한 한번에 많은 패킷을 보내는게 효율적이지만, 많은 양을 한번에 보낸다면 네트워크 환경에 따라 패킷이 유실될 때 피해가 크기에 적절한 송신양을 결정해야 한다.

TCP 헤더에서 윈도사이즈로 표현할 수 있는 최대 크기는 2^16 = 216이다.  이는 64k만큼 윈도사이즈를 가질 수 있다는 의미지만 현대에와서 이 사이즈는 너무 부족하다. 이를 해결하기 위해 **TCP 헤더 사이즈를 늘리지 않고 뒤의 숫자를 무시하는 방법으로 윈도 사이즈를 증가시켜 통신**하는데, 이런 방식을 사용하면 기존 숫자의 10배, 100배로 윈도 사이즈가 커진다.

⇒ TCP에서 데이터 유실이 발생하는 경우: 윈도 사이즈를 절반으로 줄이고 정상적인 통신이 되는 경우 서서히 원래 사이즈로 늘린다. 네트워크 경합이 발생해서 패킷 유실이 생기면 작아진 윈도 사이즈로 인해 데이터 통신 속도가 느려져 회선을 제대로 사용하지 못하는 경우가 생길 수 있는데, 이를 해결하기 위해 회선 속도 증가, 버퍼가 큰 네트워크 장비 사용 아니면 TCP 최적화 솔루션을 통해 문제를 해결할 수 있다.

### **3방향 핸드셰이크**

TCP에서는 유실없는 안전한 통신을 위해 통신 시작 전에 사전 연결 작업을 함. (데이터를 받을 준비가 안 된 상황에서 데이터를 일방적으로 전송하면 목적지에서는 데이터를 정상적으로 처리할 수 없어 데이터가 버려짐)

패킷 네트워크에서는 동시에 많은 상대방과 통신하므로 정확한 통신을 위해서는 통신 전, 각 통신에 필요한 리소스를 미리 확보하는 작업이 중요하다.

⇒ TCP에서는 3번의 패킷을 주고받으면서 통신을 서로 준비한다. 이를 ‘**3방향 핸드셰이크**’라고 부른다.

TCP에서는 이런 3방향 핸드셰이크를 진행 상황에 따라 상태 정보를 부르는 이름이 다르다.

- **LISTEN**: 서버에서 서비스를 제공하기 위해 클라이언트 접속을 받아들일 수 있는 상태
- **SYN-SENT**: 클라이언트에서 SYN 패킷을 보내는 상태
- **SYN-RECEIVE**: 클라이언트의 SYN 패킷을 받은 서버의 상태
- **ESTABLISHED:**
    - 클라이언트일 경우 :  서버로부터 SYN, ACK 응답받은 상태
    - 서버일 경우:  클라이언트로부터 ACK 응답받은 상태

### 3방향 핸드셰이크 실행 순서

1. 서버는 서비스를 제공하기 위해 클라이언트의 접속을 받아들일 수 있는 **LISTEN** 상태로 대기한다.  
2. 클라이언트에서는 통신을 시도할 때 SYN 패킷을 보내며 이 상태를 **SYN-SENT**라 하는데 서버에서는 클라이언트의 SYN 패킷을 받으면 SYN-RECEIVE 상태로 변경되고 클라이언트로 SYN, ACK을 응답한다. 
3. 클라이언트는 이 응답(SYN, ACK)을 받으면 **ESTABLISHED** 상태로 변경되고 이에 대한 응답(ACK)을 다시 서버로 보낸다.  
4. 서버에서도 이 응답을 받고 **ESTABLISHED**상태로 변경되며 클라이언트와 서버 양 측이 모두 **ESTABLISHED** 상태가 되었다는 것은 연결이 성공적으로 완료되었음을 나타낸다.

⇒ 3방향 핸드셰이크 과정이 생김으로 인해 기존 통신과 새로운 통신을 구분해야 하는데, 이를 구분하기 위해 헤더에 플래그(flag)라는 것을 넣어 통신한다. TCP 플래그는 총 6가지로 통신의 성질을 나타낸다.

모든 플래그는 1비트로 정의되고 아래의 순서대로 배열된다.

- **SYN(연결 시작)**: 연결 시작 용도로 사용한다. 연결이 시작될 때 SYN 플래그에 1로 표시해 보낸다.
- **ACK(확인 응답):** ACK 번호가 유효할 경우 1로 표시해 보낸다. 
초기 SYN이 아닌 모든 패킷은 기존 메세지에 대한 응답이기에 ACK 플래그가 1로 표기된다.
- **RST(강제 연결 종료)**: 연결 종료 시 1로 표시된다. 연결 강제 종료를 위해 연결을 일방적으로 끊을 때 사용된다.
- **PSH(삽입)**: 서버측에서 전송할 데이터가 없거나 데이터를 버퍼링 없이 응용 프로그램으로 즉시 전달 할 것을 지시할 때 사용된다.
- **URG(긴급)**: 긴급 데이터인 경우, 1로 표시해 보낸다.
- **FIN(종료)**: 연결 종료 시 1로  표시된다. 데이터 전송을 마친 후 정상적으로 양방향 종료 시 사용된다

## UDP(User Datagram Protocol)

: TCP와 달리 UDP는 4계층 프로토콜이 가져야 할 특징이 거의 없다. TCP에서 소개한 4계층의 여러 안전 장치 기능들이 UDP에는 없고, UDP 헤더도 TCP 헤더와 비교하면 내용이 거의 없다.
⇒ UDP는 데이터 전송을 보장하지 않는 프로토콜이므로 제한된 용도로만 사용함

### UDP의 용도

- 음성 데이터나 실시간 스트리밍과 같이 시간에 민감한 프로토콜이나 애플리케이션을 사용
- 사내 방송이나 증권 시세 데이터 전송에 사용되는 멀티캐스트처럼 단방향으로 다수의 단말과 통신해 응답을 받기 어려운 환경에서 주로 사용

⇒ 신뢰성보다는 일부 데이터가 유실되더라도 시간에 맞춰서 계속 전송하는것이 중요한 시스템에서 UDP를 사용하게 된다. **UDP에서는 일부 데이터가 유실되더라도 그대로 데이터를 처리한다.**

### UDP의 특징

- UDP는 TCP와 다르게 3방향 핸드셰이크처럼 사전에 연결을 확립하는 과정이 없다. 대신 UDP의 첫 데이터는 리소스 확보를 위해 인터럽트(Interrupt)를 거는 용도로 사용되고 유실된다 (UDP 프로토콜을 사용하는 앱 대부분은 이런 상황을 인지하고 동작함)
- 연결 확립은 TCP 프로토콜을 이용하고 앱끼리 모든 준비를 마친 후 실제 데이터만 UDP를 이용하는 경우가 대부분이다.

---

# ARP(Address Resolution Protocol)

: 앞서 반복한 내용처럼 데이터 통신을 위해 2계층 물리적 주소인 MAC 주소와 3계층 논리적 IP 주소 두 개가 사용된다. **IP 주소 체계는 물리적 MAC 주소와 전혀 연관성이 없으므로 두 개의 주소를 연계시켜 주기 위한 메커니즘**이 필요한데, 이때 사용되는 프로토콜이 **ARP**이다.

⇒ 상대방의 MAC 주소를 알아내기 위해 사용되는 프로토콜

## ARP 구성

⇒ 2계층과 3계층 정보가 모두 포함되어 있음. 
⇒ 처음에 통신을 시도할 때 패킷을 바로 캡슐화 할 수 없는데, 호스트에서 목적지 IP 주소는 미리 파악 가능하지만 상대방의 MAC 주소를 알 수 없기 때문이다. 상대방의 MAC 주소를 알아내기 위해서는 ARP 브로드캐스트를 이용해서 네트워크 전체에 상대방의 MAC 주소를 물어봐서 알아내야 한다.

⇒ ARP 브로드캐스트를 받은 목적지는 ARP 프로토콜로 자신의 MAC 주소를 응답하는데, 이 작업이 완료되면 패킷은 정상적으로 인캡슐레이션 되어 상대방에게 전달된다.

⇒ 최초 통신시 ARP 브로드캐스트를 이용해서 네트워크 전체에 물어봐야하는데, 매번 물어보는 것은 비용낭비가 있기 때문에 IP 주소와 MAC 주소를 일대일로 대응하여 ARP Table 에 저장해둔다. 

- 성능을 위해서 ARP 테이블이 한번 생성되면 오래 유지될수록 좋다
- 논리 주소는 바뀔 수 있기 때문에 일정 시간 이상 통신이 없으면 이 테이블은 삭제된다
- 짧은 시간에 많은 ARP 요청이 들어오면 네트워크 장비에는 큰 부하가 걸리는데, 이를 해결하기 위해 다음과 같은 방법을 사용한다
    - ARP 테이블 저장 기간을 일반 PC 보다 길게 설정
    - 많은 ARP 요청이 들어오면 필터링하거나 천천히 처리
    - ARP 테이블을 수동으로만 갱신하도록 설정해 운영
    

## ARP 동작

ARP 프로토콜 중 중요한 네가지 필드를 살펴보자.

- 송진자 하드웨어 MAC 주소
- 송신자 IP 프로토콜 주소
- 대상자 MAC 주소
- 대상자 IP 프로토콜 주소

이 네가지 필드를 이용해 ARP 가 어떻게 동작하는지 알아보자.

### 1. 서버 A→ 서버 B로 최초 통신 시도

- 목적지 MAC 주소를 모르기에 패킷을 완성할 수 없다
- 서버 A는 서버 B의 MAC 주소를 알아내기 위해 ARP 요청을 브로드캐스트 한다.

### 2. **서버 A → 서버 B로 ARP 브로드 캐스트**

- 2계층 MAC 주소는 출발지를 자신의 MAC 으로, 도착지는 브로드캐스트한다.
- ARP 프로토콜 필드의 전송자 MAC과 IP 주소로 채운다.
- 대상자 IP 주소 1.1.1.2로 대상자 MAC 주소는 00-00-00-00-00-00 으로 채워 보낸다.

### 3. **브로드캐스트를 받은 서버에서는 IP 비교후 자신의 MAC 주소 반환**
- ARP 패킷은 같은 네트워크 내의 모든 단말에 보내졌다(2번에서 브로드캐스트함)
- 모든 단말은 각자 ARP 프로토콜을 확인한 뒤 대상자 IP와 자신의 IP를 비교해서 일치하지 않으면 폐기하고, 일치하면 ARP 프로토콜 필드를 통해 목적지 정보(IP, MAC)를 이용해 유니캐스트로 목적지에 ARP 프로토콜을 전송한다.

### 4. **ARP 캐시 테이블 갱신 및 서버 A → 서버 B 패킷 송신**
- 서버 A는 서버 B로부터 ARP 응답을 받아 자신의 ARP 캐시 테이블을 갱신한다.
- ARP 캐시 테이블 갱신 후에는 상대방의 MAC 주소를 알고 있으니 도착지 MAC 주소 필드도 완성해서 인캡슐레이션 해서 정상적으로 패킷을 보낼 수 있다.

## GARP

: ARP 프로토콜 필드를 그대로 사용하지만 내용을 변경해 다른 목적과 용도로 사용하는 프로토콜

- 대상자 IP 필드에 자신의 IP 주소를 채워 ARP 요청을 보낸다
- 자신의 IP와 MAC 주소를 알릴 목적으로 사용된다
- 로컬 네트워크에 자신의 주소 정보를 알릴 목적이기에 목적지 MAC 주소는 브로드캐스트 MAC 주소를 사용한다.
- GARP를 사용해 동일 네트워크에 자신의 주소 정보를 알리는 이유
    1. IP 주소 충돌 감지: 내가 할당받은 IP를 다른 사람이 사용하고 있을 수 있기 때문(충돌예방)
    2. 상대방(동일 서브넷 상의 다른)의 ARP 테이블 갱신
    3. HA 용도의 클러스터링, VRRP, HSRP

## RARP(Reverse ARP)

: 반대로 동작하는 ARP

- 필드에 들어가는 내용이 다르고 원래 목적과 반대로 사용한다
- IP 주소가 정해져 있지 않은 단말이 IP 할당을 요청할 때 사용한다
- 현재 제한된 기능으로 BOOTP와 DHCP로 대체되어 사용되지 않는다

---

# 서브넷과 게이트웨이

## 서브넷과 게이트웨이의 용도

초기와 다르게 인터넷 기술의 발달로 먼 거리에 있는 다른 LAN 간의 통신이 중요해짐

- **게이트웨이**: 원격지 네트워크와의 통신에 사용되는 장비
    - 원격 네트워크 통신에서 네트워크를 넘어 전달되지 못하는 브로드캐스트의 성질 때문에 장비의 도움이 필요하다. 이 장비를 게이트웨이라 부르고 3계층 장비(라우터와 L3 스위치)가 이 역할을 할 수 있다.
    - 게이트웨이에 대한 정보를 PC나 네트워크 장비에 설정하는 항목이 **기본 게이트웨이** 이다. 기본 게이트웨이는 3계층 장비가 수행하고 여러 네트워크와 연결되면서 적절한 경로를 지정해준다.
- 출발지와 목적지 네트워크가 동일한 LAN 내에서 통신하는 것인지 다른 네트워크 간의 통신인지에 따라 통신 방식이 달라지기 때문에, **서브넷 마스크**를 이용해 먼저 목적지의 범위를 확인한다. (서브넷 마스크와 자신의 IP 주소와 서브넷 마스크를 and 연산해 자신이 속한 네트워크 주소를 확인할 수 있다)
- 정리: **원격지 통신은 ARP 가 라우터를 넘어가지 못하는 브로드캐스트이기 때문에 게이트웨이라는 장비를 사용해야 한다.**

## 2계층 통신 vs 3계층 통신

### 3계층 통신: 원격지 네트워크 통신

- 원격지 네트워크와 통신해야할 경우 라우터 같은 3계층 장비의 도움이 필요하기에 해당 패킷을 전송하는 네트워크 장비에서 3계층 정보까지 확인해야 한다. 이를 **L3 통신** 이라고 한다.
- 도착지 MAC 주소와 IP 주소가 다르다. 도착지 IP 주소는 실제 도착지이고 도착지 MAC 주소는 디폴트 게이트웨이의 MAC 주소가 사용된다.

### 2계층 통신: 로컬 네트워크 통신

- 로컬 네트워크에서 직접 통신할 때 라우터와 같은 3계층 장비 없이도 통신이 가능하다.
- 2계층까지만 정보를 확인한 후에 ARP 요청을 보낼 때 직접 브로드 캐스트를 이용한다. 이를 **L2 통신**이라 한다.
- 도착지 MAC 주소와 IP 주소가 같다.

⇒ 정리: 통신하는 출발지와 도착지의 네트워크가 같은지, 다른지에 따라 통신 방식이 달라지는데 이는 로컬과 원격 통신을 위한 ARP 동작 방식이 달라서 발생하는 차이이다.

⇒ 같은 네트워크에 있는 단말 간 통신은 직접적으로 이루어진다. 상대방 MAC 주소를 알아내기 위해 ARP 브로드캐스트를 이용하고, 알아내자마자 패킷이 캡슐화되어 통신이 시작된다.

⇒ 외부 네트워크와 통신할 때는 단말이 자신이 직접 보낼 수 없는 위치에 목적지가 있다고 판단해 ARP 요청을 기본 게이트웨이의 IP 주소로 요청한다. 게이트웨이에서 ARP 응답을 받은 단말은 도착지 MAC 주소에 응답받은 기본 게이트웨이의 MAC 주소를 적어넣고 통신을 시작한다.